
import textdistance
import numpy as np


aisles = ["AB","AD","ABCD","ABC","AB","AC","AD","BD","BC","BCD"]     #list will be generated by part1 code
length = len(aisles)
leven_matrix = np.zeros((length,length))                            #initialise an empty matrix 


def invalidate(start,id,col):               #once aisles of user are processed, mark them as 999 so that they won't be 
    if col:                                 #considered for further batches 
        for i in range(start,length):
            leven_matrix[id][i] = 999
        for j in range(0,length):
            leven_matrix[j][id] = 999
    else:                                   #we don't want to overwrite the current index column.
        for i in range(start,length):
            leven_matrix[id][i] = 999


for i in range(0,length):                   #mark the diagnoals 999
    for j in range(0,length):
        if i == j:
            leven_matrix[i][j] = 999


done = []                                   #list of processed elements
batches = []                                #list of aisles in group of 3
for i in range(0,length):
    if i not in done and len(batches)!=3:
        current = aisles[i]
        col = []
        top3 = []
        
        for j in range(0,length):
            if i == j:
                col.append(leven_matrix[i][j])
            else:
                if j not in done:
                    dst = textdistance.levenshtein(current,aisles[j])
                    leven_matrix[j][i] = dst
                    col.append(dst)
                else:
                    col.append(leven_matrix[j][i])      #999              
                
        sorted_list = sorted(range(len(col)), key=lambda k: col[k])    #sort the column values and get indexes of sorted values.
        
        id1,id2 = sorted_list[:2]           #get top 2 indexes
        done.append(id1)                    #mark it as "processed"
        invalidate(i+1,id1,True)            #mark row and column values to 999
        done.append(id2)                    
        invalidate(i+1,id2,True)
        
        top3.append(current)
        top3.append(aisles[id1])
        top3.append(aisles[id2])            
        if i not in done: done.append(i)
        invalidate(i+1,i,False)

        batches.append(top3)
batch = []

print("\n Final matrix values: \n")

print(leven_matrix)            #print final matrix

for i in range(0,length):
    if i not in done:           #as we have 10 orders, and batches of three, one order will be left, add it to "batches"
        batch.append(aisles[i])

batches.append(batch)
print("\n Batches: \n")

print(batches)                 #final batches





'''
Output:

(base) E:\>python lavenstein.py

 Final matrix values:

[[999. 999. 999. 999. 999. 999. 999. 999. 999. 999.]
 [  1. 999. 999. 999. 999. 999. 999. 999. 999. 999.]
 [  2. 999. 999. 999. 999. 999. 999. 999. 999. 999.]
 [  1. 999.   1. 999. 999. 999. 999. 999. 999. 999.]
 [  0. 999. 999. 999. 999. 999. 999. 999. 999. 999.]
 [  1. 999.   2. 999. 999. 999. 999. 999. 999. 999.]
 [  1. 999.   2. 999. 999.   1. 999. 999. 999. 999.]
 [  2. 999.   2. 999. 999.   2. 999. 999. 999. 999.]
 [  2. 999.   2. 999. 999.   1. 999. 999. 999. 999.]
 [  3. 999.   1. 999. 999. 999. 999. 999. 999. 999.]]

 Batches:

[['AB', 'AB', 'AD'], ['ABCD', 'ABC', 'BCD'], ['AC', 'AD', 'BC'], ['BD']]

'''
